#include "util.pwgsl"

override CONSTV_0 : u32 = 0u;
override CONSTV_1 : u32 = 1u;

#define op_reduce_operation                     CONSTV_0
#define op_reduce_length                        op_meta[0]

#define op_reduce_workgroup_count               min(64u, op_reduce_length)

#define op_reduce_output_to_start_stride1       op_meta[1]
#define op_reduce_output_to_start_shape_stride2 op_meta[2]
#define op_reduce_output_to_start_stride2       op_meta[3]
#define op_reduce_stride_reduction              CONSTV_1
#define op_reduce_dest_size                     op_meta[4]
#define op_reduce_input_layout                  5u

var<workgroup> sharedSums: array<DTYPE, 64>; 
var<workgroup> sharedIndex: array<u32, 64>; 

override USE_Z : bool = false;


//for reduction over large number of elements, 
//specially if stride_reduced_dim == 1, in this case multiple threads can read coallesced memory
@compute
@workgroup_size(64,1,1)
fn reduce(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let tid = global_id.x;
    let output_index = global_id.y + select(USE_Z, global_id.z * 65535, 0u);
    
    //Start Index of the Elements to Reduce

    var start_index = 0u;// = output_index * op_reduce_output_to_start_stride1 + (output_index / op_reduce_output_to_start_shape_stride2) * op_reduce_output_to_start_stride2;
    if op_reduce_output_to_start_shape_stride2 <= 1
    {
        start_index = output_index * op_reduce_output_to_start_stride1;
    }
    else{
        start_index = output_index * op_reduce_output_to_start_stride1 + (output_index / op_reduce_output_to_start_shape_stride2) * op_reduce_output_to_start_stride2;
    }
    
    let length = op_reduce_length; //length of the elements to reduce

    //We split the Reduction into 64 threads -> find the sub region we need to reduce over 
    if(output_index < op_reduce_dest_size || !USE_Z)
    {
        //Now Reduce from start to end
        switch(op_reduce_operation){
            case 0u{ //sum
                var sum = ZERO;
                for (var i = tid; i < length; i += 64u) {
                    let index = get_index1(op_reduce_input_layout, start_index + i * op_reduce_stride_reduction).id;
                    sum += v_input1[index];
                }
                sharedSums[tid] = sum;
            }
            case 1u{ //min
                var sum = MAXVALUE;
                for (var i = tid; i < length; i += 64u) {
                    let index = get_index1(op_reduce_input_layout, start_index + i * op_reduce_stride_reduction).id;
                    sum = min(sum, v_input1[index]);
                }
                sharedSums[tid] = sum;
            }
            case 2u{ //max
                var sum = MINVALUE;
                for (var i = tid; i < length; i += 64u) {
                    let index = get_index1(op_reduce_input_layout, start_index + i * op_reduce_stride_reduction).id;
                    sum = max(sum, v_input1[index]);
                }
                sharedSums[tid] = sum;
            }
            default{

            }
        }
    }

    workgroupBarrier();
    //This is not optimal (only 1 of 64 threads sums the partial result of each thread)
    //TODO: Either use multiple threads for the sum(e.g. first 32 threads, then 16, then 8, ...)
    //      or let one thread calculate multiple outputs in sharedSums, and then let multiple threads sum the partial results of one output(like in matmul1x64b) 
    if (tid == 0 && (output_index < op_reduce_dest_size || !USE_Z)){
        let cnt = op_reduce_workgroup_count;
        //Finnaly Sum of all worker threads:

        switch(op_reduce_operation){
            case 0u{ //sum
                var sum = ZERO;
                for (var i = 0u; i < cnt; i++){
                    sum +=  sharedSums[i];
                }
                v_dest[output_index] = sum;
            }
            case 1u{ //min
                var sum = sharedSums[0];
                for (var i = 0u; i < cnt; i++){
                    sum = min(sum, sharedSums[i]);
                }
                v_dest[output_index] = sum;
            }
            case 2u{ //max
                var sum = sharedSums[0];
                for (var i = 0u; i < cnt; i++){
                    sum = max(sum, sharedSums[i]);
                }
                v_dest[output_index] = sum;
            }
            default{

            }
        }
    }
}


@compute
@workgroup_size(64,1,1)
fn reduce_index(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let tid = global_id.x;
    let output_index = global_id.y + select(USE_Z, global_id.z * 65535, 0u);

    //Start Index of the Elements to Reduce
    var start_index = 0u;
    if op_reduce_output_to_start_shape_stride2 <= 1
    {
        start_index = output_index * op_reduce_output_to_start_stride1;
    }
    else{
        start_index = output_index * op_reduce_output_to_start_stride1 + (output_index / op_reduce_output_to_start_shape_stride2) * op_reduce_output_to_start_stride2;
    }
    
    let length = op_reduce_length; //length of the elements to reduce

    //We split the Reduction into 64 threads -> find the sub region we need to reduce over 
    if(output_index < op_reduce_dest_size || !USE_Z)
    {
        //Now Reduce from start to end
        switch(op_reduce_operation){
            case 3u{//ArgMin
                var sum = MAXVALUE;
                var arg_index = 0u;
                
                for (var i = tid; i < length; i += 64u) {
                    let index = get_index1(op_reduce_input_layout, start_index + i * op_reduce_stride_reduction).id;
                    if v_input1[index] < sum{
                        sum = v_input1[index];
                        arg_index = i;
                    }
                }
                sharedSums[tid] = sum;    
                sharedIndex[tid] = arg_index;
            }
            case 4u{//ArgMax
                var sum = MINVALUE;
                var arg_index = 0u;
                for (var i = tid; i < length; i += 64u) {
                    let index = get_index1(op_reduce_input_layout, start_index + i * op_reduce_stride_reduction).id;
                    if v_input1[index] > sum{
                        sum = v_input1[index];
                        arg_index = i;
                    }
                }
                sharedSums[tid] = sum;    
                sharedIndex[tid] = arg_index;
            }
            default{

            }
        }
    }

    workgroupBarrier();
    
    if (tid == 0 && (output_index < op_reduce_dest_size || !USE_Z)){
        let cnt = op_reduce_workgroup_count;
        //Finnaly Sum of all worker threads:
        
        switch(op_reduce_operation){
            case 3u{//ArgMin
                var sum = sharedSums[0];
                var index = 0u;
                for (var i = 0u; i < cnt; i++){
                    if sharedSums[i] < sum{
                        sum = sharedSums[i];
                        index = i;
                    }
                }
                v_dest_u32[output_index] = sharedIndex[index];
            }
            case 4u{//ArgMax
                var sum = sharedSums[0];
                var index = 0u;
                for (var i = 0u; i < cnt; i++){
                    if sharedSums[i] > sum{
                        sum = sharedSums[i];
                        index = i;
                    }
                }
                v_dest_u32[output_index] = sharedIndex[index];
            }
            default{

            }
        }
    }
}



//for reduce operations, where reduce length is small(e.g. much smaller than 64, or where stride_length != 1)
@compute
@workgroup_size(1,64,1)
fn reduce_small(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let output_index = global_id.y + select(USE_Z, global_id.z * 65535 * 64, 0u);
    var start_index = 0u;
    if op_reduce_output_to_start_shape_stride2 <= 1
    {
        start_index = output_index * op_reduce_output_to_start_stride1;
    }
    else{
        start_index = output_index * op_reduce_output_to_start_stride1 + (output_index / op_reduce_output_to_start_shape_stride2) * op_reduce_output_to_start_stride2;
    }
    
    let length = op_reduce_length; //length of the elements to reduce

    if(output_index < op_reduce_dest_size || !USE_Z)
    {
        //Now Reduce from start to end
        switch(op_reduce_operation){
            case 0u{ //sum
                var sum = ZERO;
                for (var i = 0u; i < length; i += 1u) {
                    let index = get_index1(op_reduce_input_layout, start_index + i * op_reduce_stride_reduction).id;
                    sum += v_input1[index];
                }
                v_dest[output_index] = sum;
            }
            case 1u{ //min
                var sum = MAXVALUE;
                for (var i = 0u; i < length; i += 1u) {
                    let index = get_index1(op_reduce_input_layout, start_index + i * op_reduce_stride_reduction).id;
                    sum = min(sum, v_input1[index]);
                }
                v_dest[output_index] = sum;
            }
            case 2u{ //max
                var sum = MINVALUE;
                for (var i = 0u; i < length; i += 1u) {
                    let index = get_index1(op_reduce_input_layout, start_index + i * op_reduce_stride_reduction).id;
                    sum = max(sum, v_input1[index]);
                }
                v_dest[output_index] = sum;
            }
            default{

            }
        }
    }
}


@compute
@workgroup_size(1,64,1)
fn reduce_index_small(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let output_index = global_id.y + select(USE_Z, global_id.z * 65535 * 64, 0u);

    //Start Index of the Elements to Reduce
    var start_index = 0u;
    if op_reduce_output_to_start_shape_stride2 <= 1
    {
        start_index = output_index * op_reduce_output_to_start_stride1;
    }
    else{
        start_index = output_index * op_reduce_output_to_start_stride1 + (output_index / op_reduce_output_to_start_shape_stride2) * op_reduce_output_to_start_stride2;
    }
    
    let length = op_reduce_length; //length of the elements to reduce
    if(output_index < op_reduce_dest_size || !USE_Z)
    {
        //Now Reduce from start to end
        switch(op_reduce_operation){
            case 3u{//ArgMin
                var sum = MAXVALUE;
                var arg_index = 0u;
                
                for (var i = 0u; i < length; i += 1u) {
                    let index = get_index1(op_reduce_input_layout, start_index + i * op_reduce_stride_reduction).id;
                    if v_input1[index] < sum{
                        sum = v_input1[index];
                        arg_index = i;
                    }
                }
                v_dest_u32[output_index] = arg_index;
            }
            case 4u{//ArgMax
                var sum = MINVALUE;
                var arg_index = 0u;
                for (var i = 0u; i < length; i += 1u) {
                    let index = get_index1(op_reduce_input_layout, start_index + i * op_reduce_stride_reduction).id;
                    if v_input1[index] > sum{
                        sum = v_input1[index];
                        arg_index = i;
                    }
                }
                v_dest_u32[output_index] = arg_index;
            }
            default{

            }
        }
    }
}