#include "../util.pwgsl"


override CONSTV_0 : bool = true;
override CONSTV_1 : bool = true;
override CONSTV_2 : bool = true;
override CONSTV_3 : bool = true;
override CONSTV_4 : bool = true;
override CONSTV_5 : u32 = 0u;

#define op_matmul_input1_stride_k   CONSTV_0
#define op_matmul_input1_stride_m   CONSTV_1

#define op_matmul_input2_stride_n   CONSTV_2
#define op_matmul_input2_stride_k   CONSTV_3

#define op_matmul_use_batch   CONSTV_4
#define op_matmul_dest_offset CONSTV_5

#define op_matmul_b                 op_meta[0]
#define op_matmul_m                 op_meta[1]
#define op_matmul_k                 op_meta[2]
#define op_matmul_n                 op_meta[3]

#define op_matmul_input1_stride_b   op_meta[4]
#define op_matmul_input1_offset     op_meta[5]

#define op_matmul_input2_stride_b   op_meta[6]
#define op_matmul_input2_offset     op_meta[7]

#define op_matmul_input1_stride_k   select(CONSTV_0, 1u, op_meta[8])
#define op_matmul_input1_stride_m   select(CONSTV_1, 1u, op_meta[9]) 

#define op_matmul_input2_stride_n   select(CONSTV_2, 1u, op_meta[10])
#define op_matmul_input2_stride_k   select(CONSTV_3, 1u, op_meta[11])

#ifndef RTSM
#definec RTSM 1
#endif
#ifndef RTSN
#definec RTSN (TSN / WPTN) * THREADS_PER_K
#endif

#definec THREADS RTSM * RTSN

#definec WPTN_DEST TSN / THREADS
#assert ((TSN)%(THREADS)) == 0

#assert ((TSK*TSN)%(THREADS)) == 0
#assert RTSM > 0
#assert RTSN > 0
#assert TSM % WPTM == 0
#assert TSN % WPTN == 0

#assert (THREADS_PER_K * WPTK) == TSK

#ifndef WIDTHA
#define WIDTHA WPTK
#endif

#ifndef WIDTHB
#define WIDTHB WPTK
#endif

#if WIDTHA == 1
#define ARRAY_TYPEA DTYPE
#elif WIDTHA == 2
#define ARRAY_TYPEA vec2<DTYPE>
#elif WIDTHA == 4
#define ARRAY_TYPEA vec4<DTYPE>
#endif

#if WIDTHB == 1
#define ARRAY_TYPEB DTYPE
#elif WIDTHB == 2
#define ARRAY_TYPEB vec2<DTYPE>
#elif WIDTHB == 4
#define ARRAY_TYPEB vec4<DTYPE>
#endif


@group(0) @binding(2)
var<storage> v_input_a: array<ARRAY_TYPEA>;

@group(0) @binding(3)
var<storage> v_input_b: array<ARRAY_TYPEB>;

var<workgroup> SharedResult: array<array<DTYPE, THREADS_PER_K>, TSN>;

//This is an optimized shader for m = 1 and B k_stride = 1:
//this shader will dispatch multiple threads (THREADS_PER_K) to a single matmul k sum (so that adjacent threads will load adjacent memory from A and B). 
//Each thread will compute only a part of the total sum, but will compute many columns (wptn is higher (e.g. 32)).
//all partial results are stored in sharedResults
//At the end, each thread will sum one column of the partial results and write it to memory.
fn generic_sgemm(group_id: vec3<u32>, local_id: vec3<u32>) {

    let lk = local_id.x % THREADS_PER_K;
    let local_x = local_id.x / THREADS_PER_K;

    let lx = local_x * WPTN;

    let input1_stride_b = select(op_matmul_use_batch, op_matmul_input1_stride_b, 0u); 
    let input2_stride_b = select(op_matmul_use_batch, op_matmul_input2_stride_b, 0u); 

    let m_input1_offset = (op_matmul_input1_offset + op_matmul_input1_stride_m * TSM * group_id.y + group_id.z * input1_stride_b);
    let m_input2_offset = (op_matmul_input2_offset + op_matmul_input2_stride_n * TSN * group_id.x + group_id.z * input2_stride_b);

    let max_k = op_matmul_k;
    var acc = array<DTYPE, WPTN>();
    for(var k = lk*WPTK; k < max_k; k += TSK){
        let id_a = m_input1_offset + k * op_matmul_input1_stride_k;
        let id_b = m_input2_offset + k * op_matmul_input2_stride_k + lx * op_matmul_input2_stride_n;

        #assert WPTK == WIDTHA
        #assert WPTK == WIDTHB
        let a_reg : ARRAY_TYPEA = v_input_a[id_a / WIDTHA];

        for (var wn=0u; wn<WPTN; wn++) {
            let id_b2 = id_b + wn * op_matmul_input2_stride_n;
            let b_reg : ARRAY_TYPEB = v_input_b[id_b2 / WIDTHB];

            #if WPTK == 1
                acc[wn] += a_reg* b_reg;
            #else
                #ifdef f32
                  acc[wn] += dot(a_reg, b_reg);
                #else
                    for(var ki=0u; ki < WPTK; ki++){
                        acc[wn] += a_reg[ki] * b_reg[ki];
                    }
                #endif 
            #endif
        }
    }
    for (var wn=0u; wn<WPTN; wn++) {
        SharedResult[wn + lx][lk] = acc[wn];
    }
    
    workgroupBarrier();

    let gx = TSN*group_id.x;
    let gy = TSM*group_id.y;

    let dest_index = group_id.z * select(op_matmul_use_batch, op_matmul_m * op_matmul_n, 0u) + gy * op_matmul_n + gx + op_matmul_dest_offset;
    let tid = local_id.x;
    for (var t=0u; t<WPTN_DEST; t++) {
        let wn = tid + t * THREADS;
        var sum : DTYPE = ZERO;
        for (var li =0u; li<THREADS_PER_K; li++) {
            sum += SharedResult[wn][li];
        }
        v_dest[dest_index + wn] = sum;
    }
}