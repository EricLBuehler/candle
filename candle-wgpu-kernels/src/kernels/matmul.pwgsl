#include "util.pwgsl"

override CONSTV_0 : bool = true;
override CONSTV_1 : bool = true;
override CONSTV_2 : bool = true;
override CONSTV_3 : bool = true;
override CONSTV_4 : bool = true;

#define op_matmul_use_batch   CONSTV_4

#define TS1 16u

#define op_matmul_b                 op_meta[0]
#define op_matmul_m                 op_meta[1]
#define op_matmul_k                 op_meta[2]
#define op_matmul_n                 op_meta[3]

#define op_matmul_input1_stride_b   op_meta[4]
#define op_matmul_input1_offset     op_meta[5]

#define op_matmul_input2_stride_b   op_meta[6]
#define op_matmul_input2_offset     op_meta[7]

#define op_matmul_input1_stride_k   select(CONSTV_0, 1u, op_meta[8])
#define op_matmul_input1_stride_m   select(CONSTV_1, 1u, op_meta[9]) 

#define op_matmul_input2_stride_n   select(CONSTV_2, 1u, op_meta[10])
#define op_matmul_input2_stride_k   select(CONSTV_3, 1u, op_meta[11])

#define op_matmul_gx_offset     op_meta[12]
#define op_matmul_gy_offset     op_meta[13]

@compute
@workgroup_size(16,16,1)
fn matmul1(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let x = global_id.x;
    let y = global_id.y;
    let b = global_id.z;

    if(x >= op_matmul_n){
        return;
    }
    if(y >= op_matmul_m){
        return;
    }

    let output_size_of_one_batch = select(op_matmul_use_batch, op_matmul_m * op_matmul_n, 0u); 

    let input1_offset = op_matmul_input1_offset;
    let input2_offset = op_matmul_input2_offset;

    let input1_stride_b = select(op_matmul_use_batch, op_matmul_input1_stride_b, 0u); 
    let input2_stride_b = select(op_matmul_use_batch, op_matmul_input2_stride_b, 0u); 
    
    let m_input1_offset = input1_offset + op_matmul_input1_stride_m * y + b * input1_stride_b;
    let m_input2_offset = input2_offset + op_matmul_input2_stride_n * x + b * input2_stride_b;

    var sum = ZERO;
    for (var i = 0u; i < op_matmul_k; i++){
        sum +=  v_input1[op_matmul_input1_stride_k * i + m_input1_offset] 
                * v_input2[op_matmul_input2_stride_k * i + m_input2_offset];
    }
    
    v_dest[b * output_size_of_one_batch + y * op_matmul_n + x] = sum;
}


@group(0) @binding(2)
var<storage> v_input_a: array<vec4<DTYPE>>;

@group(0) @binding(3)
var<storage> v_input_b: array<vec4<DTYPE>>;


//input_stride_k needs to be 1!
@compute
@workgroup_size(16,16,1)
fn matmul1_16(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let x = global_id.x;
    let y = global_id.y;
    let b = global_id.z;

    if(x >= op_matmul_n){
        return;
    }
    if(y >= op_matmul_m){
        return;
    }

    let output_size_of_one_batch = select(op_matmul_use_batch, op_matmul_m * op_matmul_n, 0u); 

    let input1_offset = op_matmul_input1_offset;
    let input2_offset = op_matmul_input2_offset;

    let input1_stride_b = select(op_matmul_use_batch, op_matmul_input1_stride_b, 0u); 
    let input2_stride_b = select(op_matmul_use_batch, op_matmul_input2_stride_b, 0u); 
    
    let m_input1_offset = (input1_offset + op_matmul_input1_stride_m * y + b * input1_stride_b)/4;
    let m_input2_offset = (input2_offset + op_matmul_input2_stride_n * x + b * input2_stride_b)/4;

    var sum = ZERO;
    for (var i = 0u; i < op_matmul_k/4; i++){
        //stride k will always be 1. it is only used, so the shader compiles, if it is also set.
        sum += dot(v_input_a[i*op_matmul_input1_stride_k  + m_input1_offset],v_input_b[i*op_matmul_input2_stride_k + m_input2_offset]);
    }
    
    v_dest[b * output_size_of_one_batch + y * op_matmul_n + x] = sum;
}


var<workgroup> Asub2: array<array<DTYPE, TS1>, TS1>;
var<workgroup> Bsub2: array<array<DTYPE, TS1>, TS1>;

#define WPT1 8u
#define RTRS 2u
@compute @workgroup_size(RTRS, TS1, 1)
//MxK * KxN = MxN
//matmul 7 with logic supporting edge cases
fn matmul7(@builtin(workgroup_id) group_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>) {    
    let lx = local_id.x * WPT1;
    let ly = local_id.y;

    let gx = TS1*group_id.x + lx;
    let gy = TS1*group_id.y + ly;

    let batch = group_id.z;

    let output_size_of_one_batch = select(op_matmul_use_batch, op_matmul_m * op_matmul_n, 0u); 

    let input1_offset = op_matmul_input1_offset;
    let input2_offset = op_matmul_input2_offset;
    
    let input1_stride_b = select(op_matmul_use_batch, op_matmul_input1_stride_b, 0u); 
    let input2_stride_b = select(op_matmul_use_batch, op_matmul_input2_stride_b, 0u); 

    let m_input1_offset = input1_offset + op_matmul_input1_stride_m * gy + batch * input1_stride_b;
    let m_input2_offset = input2_offset + op_matmul_input2_stride_n * gx + batch * input2_stride_b;

    var acc = array<DTYPE, WPT1>();

    var wcount = min(op_matmul_n - gx, WPT1);
    let is_in_gy = gy < op_matmul_m;
    let is_in_gx = gx < op_matmul_n;
    let is_output_pixel = is_in_gy && is_in_gx;
    if(!is_in_gx){
       wcount = 0u; 
    }

    var max_k = op_matmul_k;
    if (op_matmul_k < TS1){
        max_k = 0u;
    }
    else{
        max_k -= TS1;
    }

    var t = 0u;
    for(; t < max_k; t+=TS1){
        let count = min(op_matmul_k - t, TS1);

        if (is_in_gy){
            for(var w = 0u; w < WPT1; w++){       
                Asub2[lx + w][ly]= v_input1[m_input1_offset + (t + lx + w) *  op_matmul_input1_stride_k];
            }
        }
        
        switch(wcount){
            case 8u{
                for(var w = 0u; w < 8u; w++){       
                    Bsub2[ly][lx + w] = v_input2[m_input2_offset + (t + ly) * op_matmul_input2_stride_k + w*op_matmul_input2_stride_n];
                }
            }
            default{
                for(var w = 0u; w < wcount; w++){       
                    Bsub2[ly][lx + w] = v_input2[m_input2_offset + (t + ly) * op_matmul_input2_stride_k + w*op_matmul_input2_stride_n];
                }
            }
        }
        

        workgroupBarrier();
        if(is_output_pixel){ 
            switch(wcount){
                case 8u{
                    for(var k = 0u; k < count; k++){
                        for(var w = 0u; w < 8u; w++){
                            acc[w] += Asub2[k][ly]*Bsub2[k][lx + w];
                        }
                    }
                }
                default{
                    for(var k = 0u; k < count; k++){
                        for(var w = 0u; w < wcount; w++){
                            acc[w] += Asub2[k][ly]*Bsub2[k][lx + w];
                        }
                    }
                }
            }
        }
        workgroupBarrier();
    }


    //last loop:
    if(t < op_matmul_k){
        let count = min(op_matmul_k - t, TS1);

        if (is_in_gy && t + lx < op_matmul_k){
            let asub_count = min(op_matmul_k - (t + lx), WPT1);
            switch(asub_count){
                case 8u{
                    for(var w = 0u; w < 8u; w++){       
                        Asub2[lx + w][ly] = v_input1[m_input1_offset + (t + lx + w) *  op_matmul_input1_stride_k];
                    }
                }
                default{
                    for(var w = 0u; w < asub_count; w++){       
                        Asub2[lx + w][ly] = v_input1[m_input1_offset + (t + lx + w) *  op_matmul_input1_stride_k];
                    }
                }
            }
        }
        if (t + ly < op_matmul_k){
            switch(wcount){
                case 8u{
                    for(var w = 0u; w < 8u; w++){       
                        Bsub2[ly][lx + w] = v_input2[m_input2_offset + (t + ly) * op_matmul_input2_stride_k + w*op_matmul_input2_stride_n];
                    }
                }
                default{
                    for(var w = 0u; w < wcount; w++){       
                        Bsub2[ly][lx + w] = v_input2[m_input2_offset + (t + ly) * op_matmul_input2_stride_k + w*op_matmul_input2_stride_n];
                    }
                }
            }
        }

        workgroupBarrier();
        if(is_output_pixel){ 
            switch(wcount){
                case 8u{
                    for(var k = 0u; k < count; k++){
                        for(var w = 0u; w < 8u; w++){
                            acc[w] += Asub2[k][ly]*Bsub2[k][lx + w];
                        }
                    }
                }
                default{
                    for(var k = 0u; k < count; k++){
                        for(var w = 0u; w < wcount; w++){
                            acc[w] += Asub2[k][ly]*Bsub2[k][lx + w];
                        }
                    }
                }
            }
        }
        workgroupBarrier();
    }


    if(is_output_pixel){
        switch(wcount){
            case 8u{
                for(var w = 0u; w < 8; w++){
                    v_dest[batch * output_size_of_one_batch + gy * op_matmul_n + gx + w] = acc[w];
                }
            }
            default{
                for(var w = 0u; w < wcount; w++){
                    v_dest[batch * output_size_of_one_batch + gy * op_matmul_n + gx + w] = acc[w];
                }
            }
        }
    }
}