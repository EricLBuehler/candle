#ifdef f32
#include "util.pwgsl"

#ifndef D_SIZE
    #define D_SIZE 2
#endif
#ifndef D_OFFSET
    #define D_OFFSET 0
#endif

#definec DATA_SIZE (BIT_SIZE*BLOCK_SIZE/16)

fn select(d : bool, value : u32, other : u32) -> u32{
    if d{
        return value;
    }
    else{
        return other;
    }
}


#define DTYPE f32
#define ZERO 0.0

@group(0) @binding(0)
var<storage, read_write> v_dest: array<f32>;

@group(0) @binding(1)
var<storage> op_meta : array<u32>;

@group(0) @binding(2) var<storage, read> v_input_u32: array<u32>;

@group(0) @binding(2) var<storage, read> v_input1: array<DTYPE>;

@group(0) @binding(3) var<storage, read> quantizedBlocks: array<u32>;

#define M_OFFSET_SIZE 0
#ifdef M_OFFSET
    #define M_OFFSET_SIZE 2
#endif
#ifndef BSUMS_SIZE
    #define BSUMS_SIZE 0
#endif

#ifndef BLOCK_BYTE_SIZE
    #definec BLOCK_BYTE_SIZE (BLOCK_SIZE * BIT_SIZE) / 8 + M_OFFSET_SIZE + D_SIZE + BSUMS_SIZE
#endif

override CONSTV_0 : bool = true;
override CONSTV_1 : bool = true;
override CONSTV_2 : bool = true;


#define op_matmul_b                 op_meta[0]
#define op_matmul_m                 op_meta[1]
#define op_matmul_k                 op_meta[2]
#define op_matmul_n                 op_meta[3]

#define op_matmul_input1_stride_b   op_meta[4]
#define op_matmul_input1_offset     op_meta[5]
#define op_matmul_input2_stride_b   op_meta[6]
#define op_matmul_input2_offset     op_meta[7]

#define op_matmul_input1_stride_k   select(CONSTV_0, 1u, op_meta[8])
#define op_matmul_input1_stride_m   select(CONSTV_1, 1u, op_meta[9]) 

#define op_matmul_use_batch   CONSTV_2


#define load_data(data,idx,bit_mask) (data[(idx) / 4] >> (((idx) % 4) * 8)) & bit_mask
#define load_i8(data,idx,bit_mask) i32(((data[(idx) / 4] >> (((idx) % 4) * 8)) & bit_mask) << 24) >> 24

#define op_dequantize_size               op_meta[0]
@compute @workgroup_size(64,1,1)
fn dequantize_block_to_f32(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let block_index = global_id.x;
    if(block_index < (op_dequantize_size / BLOCK_SIZE)){
        #define data v_input_u32
        #define CALLBACK(idx,value) v_dest[idx + block_index * BLOCK_SIZE] = value;
        #include "dequantize_block_Helper.pwgsl"
    }
}

@compute @workgroup_size(16,16,1)
fn matmul_naive_block(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let x = global_id.x;
    let y = global_id.y;
    let b = global_id.z;

    if(x >= op_matmul_n){
        return;
    }
    if(y >= op_matmul_m){
        return;
    }

    let output_size_of_one_batch = select(op_matmul_use_batch, op_matmul_m * op_matmul_n, 0u); 

    let input1_offset = op_matmul_input1_offset;
    let input2_offset = op_matmul_input2_offset;

    let input1_stride_b = select(op_matmul_use_batch, op_matmul_input1_stride_b, 0u); 
    let input2_stride_b = select(op_matmul_use_batch, op_matmul_input2_stride_b, 0u); 
    
    let m_input1_offset = input1_offset + op_matmul_input1_stride_m * y + b * input1_stride_b;
    let m_input2_offset = (input2_offset + op_matmul_k * x + b * input2_stride_b) / BLOCK_SIZE;

    var sum = ZERO;
    var blk = 0u;
    for (var k = 0u; k < op_matmul_k; k+=u32(BLOCK_SIZE)){
        let block_index = blk+m_input2_offset ;
        #define CALLBACK(idx,value) sum += v_input1[op_matmul_input1_stride_k * (k + (idx)) + m_input1_offset] * (value);
        #define data quantizedBlocks
        #include "dequantize_block_Helper.pwgsl"
        blk += 1u;
    }
    v_dest[b * output_size_of_one_batch + y * op_matmul_n + x] = sum;
}

// @compute @workgroup_size(16,16,1)
// fn matmul_naive(@builtin(global_invocation_id) global_id: vec3<u32>) {
//     let x = global_id.x;
//     let y = global_id.y;
//     let b = global_id.z;

//     if(x >= op_matmul_n){
//         return;
//     }
//     if(y >= op_matmul_m){
//         return;
//     }

//     let output_size_of_one_batch = select(op_matmul_use_batch, op_matmul_m * op_matmul_n, 0u); 

//     let input1_offset = op_matmul_input1_offset;
//     let input2_offset = op_matmul_input2_offset;

//     let input1_stride_b = select(op_matmul_use_batch, op_matmul_input1_stride_b, 0u); 
//     let input2_stride_b = select(op_matmul_use_batch, op_matmul_k * op_matmul_n, 0u); 
    
//     let m_input1_offset = input1_offset + op_matmul_input1_stride_m * y + b * input1_stride_b;
//     let m_input2_offset = input2_offset + op_matmul_k * x + b * op_matmul_k * op_matmul_n;

//     var sum = ZERO;
//     for (var i = 0u; i < op_matmul_k; i++){
//         sum += v_input1[op_matmul_input1_stride_k * i + m_input1_offset] *
//                 dequantized_single2(i + m_input2_offset);
//     }
    
//     v_dest[b * output_size_of_one_batch + y * op_matmul_n + x] = sum;
// }
#endif