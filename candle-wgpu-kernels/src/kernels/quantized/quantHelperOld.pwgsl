#include "util.pwgsl"


#definec DATA_SIZE (BIT_SIZE*BLOCK_SIZE/16)

struct Block {
    scale: f32,  // Scale factor for dequantization
    
#ifdef OFFSET 
    offset: f32, // Offset if needed
#endif
};


fn select(d : bool, value : u32, other : u32) -> u32{
    if d{
        return value;
    }
    else{
        return other;
    }
}


#define DTYPE f32
#define ZERO 0.0

@group(0) @binding(0)
var<storage, read_write> v_dest: array<f32>;

@group(0) @binding(1)
var<storage> op_meta : array<u32>;

@group(0) @binding(2) var<storage, read> v_input_u32: array<u32>;

@group(0) @binding(2) var<storage, read> v_input1: array<DTYPE>;

@group(0) @binding(3) var<storage, read> quantizedBlocks: array<u32>;

#ifdef OFFSET
    #definec HEADER_BYTE_SIZE 4
   
#else
    #definec HEADER_BYTE_SIZE 2
#endif
#definec BLOCK_BYTE_SIZE (BLOCK_SIZE * BIT_SIZE) / 8 + HEADER_BYTE_SIZE


var<workgroup> Block_Data  : array<u32,TS>;
var<workgroup> Block_Header: array<Block,TS>;


override CONSTV_0 : bool = true;
override CONSTV_1 : bool = true;
override CONSTV_2 : bool = true;


#define op_matmul_b                 op_meta[0]
#define op_matmul_m                 op_meta[1]
#define op_matmul_k                 op_meta[2]
#define op_matmul_n                 op_meta[3]

#define op_matmul_input1_stride_b   op_meta[4]
#define op_matmul_input1_offset     op_meta[5]
#define op_matmul_input2_offset     op_meta[6]

#define op_matmul_input1_stride_k   select(CONSTV_0, 1u, op_meta[7])
#define op_matmul_input1_stride_m   select(CONSTV_1, 1u, op_meta[8]) 

#define op_matmul_use_batch   CONSTV_2

#ifdef f32

fn dequantized_single1(idx : u32) -> f32{
    #define data v_input_u32
    let block_index = idx / BLOCK_SIZE;
    let block_starting_byte = block_index * BLOCK_BYTE_SIZE;
    let block_data_starting_byte = block_starting_byte + HEADER_BYTE_SIZE;

    let index_inside_block = idx % BLOCK_SIZE;

    let d_u4 = data[block_starting_byte / 4];
    let d = half_to_float((d_u4 >> (block_starting_byte % 4) * 8) & 0xFFFF);

    #definec BIT_SIZE_OFFSET (((32/BIT_SIZE)-1)*BIT_SIZE)
    #if BIT_SIZE == 4 
        #define BYTE_MASK 0xF
        let byte_index_inside_block = block_data_starting_byte + index_inside_block % 16;
        let byte_offset = (index_inside_block / 16) * 4;
    #elif BIT_SIZE == 8
        #define BYTE_MASK 0xFF
        let byte_index_inside_block = block_data_starting_byte + index_inside_block; 
        let byte_offset = 0u;
    #endif

    let index_inside_block_input_index = byte_index_inside_block / 4;
    let index_inside_block_input_offset = (byte_index_inside_block % 4) * 8 + byte_offset;
    let x_u4 = data[index_inside_block_input_index];
    
    #ifdef SIGNED
        let x_unsigned = (x_u4 >> index_inside_block_input_offset) & BYTE_MASK;
        let x = i32(x << (32-BIT_SIZE)) >> (32-BIT_SIZE);
    #else
        let x = (x_u4 >> index_inside_block_input_offset) & BYTE_MASK;
    #endif
    

    #ifdef OFFSET
        let offset_starting_byte = block_starting_byte / 2;
        let m_u4 = data[offset_starting_byte / 4];
        let m = half_to_float((m_u4 >> (16 - offset_starting_byte % 4)) & 0xFFFF);
        return f32(x) * d + m; 
    #else
        return f32(x) * d; 
    #endif
}

fn dequantized_single2(idx : u32) -> f32{
    #define data quantizedBlocks
    let block_index = idx / BLOCK_SIZE;
    let block_starting_byte = block_index * BLOCK_BYTE_SIZE;
    let block_data_starting_byte = block_starting_byte + HEADER_BYTE_SIZE;

    let index_inside_block = idx % BLOCK_SIZE;

    let d_u4 = data[block_starting_byte / 4];
    let d = half_to_float((d_u4 >> (block_starting_byte % 4) * 8) & 0xFFFF);

    #definec BIT_SIZE_OFFSET (((32/BIT_SIZE)-1)*BIT_SIZE)
    #if BIT_SIZE == 4 
        #define BYTE_MASK 0xF
        let byte_index_inside_block = block_data_starting_byte + index_inside_block % 16;
        let byte_offset = (index_inside_block / 16) * 4;
    #elif BIT_SIZE == 8
        #define BYTE_MASK 0xFF
        let byte_index_inside_block = block_data_starting_byte + index_inside_block; 
        let byte_offset = 0u;
    #endif

    let index_inside_block_input_index = byte_index_inside_block / 4;
    let index_inside_block_input_offset = (byte_index_inside_block % 4) * 8 + byte_offset;
    let x_u4 = data[index_inside_block_input_index];
    
    #ifdef SIGNED
        let x_unsigned = (x_u4 >> index_inside_block_input_offset) & BYTE_MASK;
        let x = i32(x << (32-BIT_SIZE)) >> (32-BIT_SIZE);
    #else
        let x = (x_u4 >> index_inside_block_input_offset) & BYTE_MASK;
    #endif
    

    #ifdef OFFSET
        let offset_starting_byte = block_starting_byte / 2;
        let m_u4 = data[offset_starting_byte / 4];
        let m = half_to_float((m_u4 >> (16 - offset_starting_byte % 4)) & 0xFFFF);
        return f32(x) * d + m; 
    #else
        return f32(x) * d; 
    #endif
}

#define op_dequantize_size               op_meta[0]
@compute @workgroup_size(64,1,1)
fn dequantize_to_f32(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let x = global_id.x;
    if(x < op_dequantize_size){
        v_dest[x] = dequantized_single1(x);
    }
}
@compute @workgroup_size(16,16,1)
fn matmul_naive(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let x = global_id.x;
    let y = global_id.y;
    let b = global_id.z;

    if(x >= op_matmul_n){
        return;
    }
    if(y >= op_matmul_m){
        return;
    }

    let output_size_of_one_batch = select(op_matmul_use_batch, op_matmul_m * op_matmul_n, 0u); 

    let input1_offset = op_matmul_input1_offset;
    let input2_offset = op_matmul_input2_offset;

    let input1_stride_b = select(op_matmul_use_batch, op_matmul_input1_stride_b, 0u); 
    let input2_stride_b = select(op_matmul_use_batch, op_matmul_k * op_matmul_n, 0u); 
    
    let m_input1_offset = input1_offset + op_matmul_input1_stride_m * y + b * input1_stride_b;
    let m_input2_offset = input2_offset + op_matmul_k * x + b * op_matmul_k * op_matmul_n;

    var sum = ZERO;
    for (var i = 0u; i < op_matmul_k; i++){
        sum += v_input1[op_matmul_input1_stride_k * i + m_input1_offset] *
                dequantized_single2(i + m_input2_offset);
    }
    
    v_dest[b * output_size_of_one_batch + y * op_matmul_n + x] = sum;
}
#endif