
//#define CALLBACK(idx, value)
//input block_index
let block_starting_byte = block_index * BLOCK_BYTE_SIZE;

#ifdef QS_OFFSET
    let block_qs_byte = block_starting_byte + QS_OFFSET;
#endif

#if D_SIZE == 2
    let d = half_to_float(load_data(data,block_starting_byte + D_OFFSET,0xFFFF));
#elif D_SIZE == 4
    let d = as_float(data[(block_starting_byte + D_OFFSET)/4]);
#endif

#ifdef M_OFFSET
    let m = half_to_float(load_data(data,block_starting_byte+M_OFFSET,0xFFFF));
#endif

#ifdef DMIN_OFFSET
    let min = half_to_float(load_data(data,block_starting_byte+DMIN_OFFSET,0xFFFF));
#endif

#ifdef Q2K
    var is = 0u;
    let sc_offset = block_starting_byte+SCALES_OFFSET;
    var y_block_index = 0u;
    for(var qs_index = 0u; qs_index < 64; qs_index += 32u){
        let qs_offset = block_starting_byte + QS_OFFSET + qs_index;
        // Step by 32 over q.
        var shift = 0u;
        for(var _j = 0u; _j < 4u; _j += 1u) {
            var sc = load_data(data,sc_offset + is,0xFF);
            is += 1;
            var dl = d * f32(sc & 0xF);
            var ml = min * f32(sc >> 4);
            for(var q_index = 0u; q_index < 16u; q_index++){
                let q = load_data(data,qs_offset + q_index,0xFF);
                let y = dl * f32((q >> shift) & 3) - ml;
                CALLBACK(y_block_index, y);
                y_block_index += 1;
            }
            sc = load_data(data,sc_offset + is,0xFF);
            is += 1;
            dl = d * f32(sc & 0xF);
            ml = min * f32(sc >> 4);
            for(var q_index = 16u; q_index < 32u; q_index++){
                let q = load_data(data,qs_offset + q_index,0xFF);
                let y = dl * f32((q >> shift) & 3) - ml;
                CALLBACK(y_block_index, y);
                y_block_index += 1;
            }

            shift += 2;
        }
    }
        

#elifdef Q3K
    const KMASK1: u32 = 0x03030303;
    const KMASK2: u32 = 0x0f0f0f0f;

    var aux = vec4<u32>(
        load_data(data,block_starting_byte+SCALES_OFFSET,0xFFFF)      | (load_data(data,block_starting_byte+SCALES_OFFSET+2,0xFFFF)) << 16, 
        load_data(data,block_starting_byte+SCALES_OFFSET + 4u,0xFFFF) | (load_data(data,block_starting_byte+SCALES_OFFSET+6u,0xFFFF)) << 16,
        load_data(data,block_starting_byte+SCALES_OFFSET + 8u,0xFFFF) | (load_data(data,block_starting_byte+SCALES_OFFSET+10u,0xFFFF)) << 16,0u);

    let tmp = aux[2];
    aux[2] = ((aux[0] >> 4) & KMASK2) | (((tmp >> 4) & KMASK1) << 4);
    aux[3] = ((aux[1] >> 4) & KMASK2) | (((tmp >> 6) & KMASK1) << 4);
    aux[0] = (aux[0] & KMASK2) | (((tmp) & KMASK1) << 4);
    aux[1] = (aux[1] & KMASK2) | (((tmp >> 2) & KMASK1) << 4);

    //Transfer the scales into an i8 array
    let d_all = d;
    var m = 1u;
    var is = 0u;

    // Dequantize both 128 long blocks
    // 32 qs values per 128 long block
    // Each 16 elements get a scale
    for(var qs_index=0u;qs_index < 64u; qs_index+=32){
        let y_index = (qs_index / 32) * 128;
        var shift = 0u;

        for(var shift_scoped_y_index=0u; shift_scoped_y_index < 128u; shift_scoped_y_index += 32u){
            var scale_index = 0u;
            for(var scale_scoped_y_index=0u;scale_scoped_y_index < 32u; scale_scoped_y_index += 16u){
                let dl = d_all * (f32(load_i8(aux,is,0xFF)) - 32.0);

                for(var inner_y_index = 0u; inner_y_index < 16u; inner_y_index += 1u){
                    let qs_value = load_data(data,block_starting_byte + QS_OFFSET + qs_index + inner_y_index + 16 * scale_index,0xFF);
                    let h_value = load_data(data,block_starting_byte + HMASK_OFFSET          + inner_y_index + 16 * scale_index,0xFF);

                    if((h_value & m) == 0){
                        let new_y = dl* f32(i32((qs_value >> shift) & 3) - 4);
                        CALLBACK(inner_y_index + scale_scoped_y_index + shift_scoped_y_index + y_index, new_y)
                    }
                    else{
                        let new_y = dl * f32((qs_value >> shift) & 3);
                        CALLBACK(inner_y_index + scale_scoped_y_index + shift_scoped_y_index + y_index, new_y)
                    }
                } 
                // 16 block finished => advance scale index
                is += 1;
                scale_index += 1u;
            }
            // 32 block finished => increase shift and m
            shift += 2;
            m <<= 1;
        }
    }
#elifdef Q4K
    var is = 0u;
    var ys_index = 0u;
    let sc_offset = block_starting_byte+SCALES_OFFSET;
    for(var j = 0u; j < BLOCK_SIZE; j += 64u) {
        let qs_offset = block_starting_byte+QS_OFFSET + j / 2; // let q = &q[j / 2..j / 2 + 32];
       
        var sc = 0u;
        var m_load = 0u;
        #define q_is load_data(data,sc_offset + is,0xFF)
        #define q_is4 load_data(data,sc_offset + is + 4,0xFF)
        #define q_is4n load_data(data,sc_offset + is - 4,0xFF)
        if(is < 4)
        {
            sc = (q_is) & 63;
            m_load = (q_is4) & 63;
        }
        else{
            let q_is4_v = (q_is4);
            sc = (q_is4_v & 0xF) | (((q_is4n) >> 6) << 4);
            m_load = (q_is4_v >> 4) | (((q_is) >> 6) << 4);
        }
        let d1 = d * f32(sc);
        let m1 = min * f32(m_load);

        is += 1u;
        #define q_is load_data(data,sc_offset + is,0xFF)
        #define q_is4 load_data(data,sc_offset + is + 4,0xFF)
        #define q_is4n load_data(data,sc_offset + is - 4,0xFF)
        if(is < 4)
        {
            sc = (q_is) & 63;
            m_load = (q_is4) & 63;
        }
        else{
            let q_is4_v = (q_is4);
            sc = (q_is4_v & 0xF) | (((q_is4n) >> 6) << 4);
            m_load = (q_is4_v >> 4) | (((q_is) >> 6) << 4);
        }

        let d2 = d * f32(sc);
        let m2 = min * f32(m_load);
        for(var q_index = 0u; q_index < 32u; q_index++){
            let q = load_data(data,qs_offset + q_index,0xFF);
            let q1 = q & 0xF;
            let q2 = (q >> 4);
            CALLBACK(ys_index, d1 * f32(q1) - m1);
            CALLBACK(ys_index+32u, d2 * f32(q2) - m2);
            ys_index += 1u;
        }
        ys_index += 32u;
        is += 1u;
    }
#elifdef Q5K
    var is = 0u;
    var u1 = 1u;
    var u2 = 2u;
    var ys_index = 0u;
    let qh_offset = block_starting_byte+QH_OFFSET;
    let sc_offset = block_starting_byte+SCALES_OFFSET;
    for(var j = 0u; j < BLOCK_SIZE; j += 64u) {
        let ql_offset = block_starting_byte+QS_OFFSET + j / 2;  //let ql = &ql[j / 2..j / 2 + 32];

        var sc = 0u;
        var m_load = 0u;
        #define q_is load_data(data,sc_offset + is,0xFF)
        #define q_is4 load_data(data,sc_offset + is + 4,0xFF)
        #define q_is4n load_data(data,sc_offset + is - 4,0xFF)
        if(is < 4)
        {
            sc = (q_is) & 63;
            m_load = (q_is4) & 63;
        }
        else{
            let q_is4_v = (q_is4);
            sc = (q_is4_v & 0xF) | (((q_is4n) >> 6) << 4);
            m_load = (q_is4_v >> 4) | (((q_is) >> 6) << 4);
        }
        let d1 = d * f32(sc);
        let m1 = min * f32(m_load);

        is += 1u;
        #define q_is load_data(data,sc_offset + is,0xFF)
        #define q_is4 load_data(data,sc_offset + is + 4,0xFF)
        #define q_is4n load_data(data,sc_offset + is - 4,0xFF)
        if(is < 4)
        {
            sc = (q_is) & 63;
            m_load = (q_is4) & 63;
        }
        else{
            let q_is4_v = (q_is4);
            sc = (q_is4_v & 0xF) | (((q_is4n) >> 6) << 4);
            m_load = (q_is4_v >> 4) | (((q_is) >> 6) << 4);
        }

        let d2 = d * f32(sc);
        let m2 = min * f32(m_load);

        for(var q_index = 0u; q_index < 32u; q_index++){
            let ql = load_data(data,ql_offset + q_index,0xFF);
            let qh = load_data(data,qh_offset + q_index,0xFF);

            let ql1 = ql & 0xF;
            let ql2 = (ql >> 4);
            if((qh & u1) != 0u){
                CALLBACK(ys_index, d1 * (f32(ql1) + 16.0) - m1);
            }
            else{
                CALLBACK(ys_index, d1 * (f32(ql1)) - m1);
            }
            if((qh & u2) != 0u){
                CALLBACK(ys_index+32u, d2 * (f32(ql2) + 16.0) - m2);
            }
            else{
                CALLBACK(ys_index+32u, d2 * (f32(ql2)) - m2);
            }
           
            
            ys_index += 1u;
        }
        ys_index += 32u;
        is += 1u;
        u1 <<= 2;
        u2 <<= 2;
    }
#elifdef Q6K
    for (var n = 0u; n < BLOCK_SIZE; n += 128u) {
        let idx = n / 128u;
        let sc_offset = block_starting_byte+SCALES_OFFSET + 8u * idx; // let sc = &sc[8 * idx..];
        let ql_offset = block_starting_byte+QL_OFFSET + 64u * idx; // let ql = &ql[64 * idx..];
        let qh_offset = block_starting_byte+QH_OFFSET + 32u * idx; // let qh = &qh[32 * idx..];
        for (var l = 0u; l < 32u; l += 1u) {
            let is = l / 16u;

            let ql1 = load_data(data,ql_offset + l,0xFF);
            let ql2 = load_data(data,ql_offset + l + 32u,0xFF);

            let qh1 = load_data(data,qh_offset + l,0xFF);

            let q1 = i32((ql1 & 0xF) | ((qh1 & 3) << 4)) - 32;
            let q2 = i32((ql2 & 0xF) | (((qh1 >> 2) & 3) << 4))- 32;
            let q3 = i32((ql1 >> 4) | (((qh1 >> 4) & 3) << 4)) - 32;
            let q4 = i32((ql2 >> 4) | (((qh1 >> 6) & 3) << 4)) - 32;

            CALLBACK(n + l,      d * f32(load_i8(data,sc_offset+is,0xFF)) * f32(q1))
            CALLBACK(n + l + 32, d * f32(load_i8(data,sc_offset+is+2,0xFF)) * f32(q2))
            CALLBACK(n + l + 64, d * f32(load_i8(data,sc_offset+is+4,0xFF)) * f32(q3))
            CALLBACK(n + l + 96, d * f32(load_i8(data,sc_offset+is+6,0xFF)) * f32(q4))
        }
    }
#else

    #if BIT_SIZE == 4 
        #definec FOR_SIZE (BLOCK_SIZE/2) //we are loading (BLOCK_SIZE/2) bytes, and then reading low and high values
    #elif BIT_SIZE == 5
        #definec FOR_SIZE (BLOCK_SIZE/2) //we are loading (BLOCK_SIZE/2) bytes, and then reading low and high values 
    #if (QH_OFFSET % 4 == 0) && (BLOCK_BYTE_SIZE % 4 == 0)
        let qh = data[(block_starting_byte + QH_OFFSET) / 4];
    #else
        let qh = load_data(data,block_starting_byte+QH_OFFSET,0xFFFF) | (load_data(data,block_starting_byte+QH_OFFSET+2,0xFFFF)) << 16 ;
    #endif
    #else
        #define FOR_SIZE BLOCK_SIZE
    #endif


    for(var j = 0u; j < FOR_SIZE;j++){
        #if BIT_SIZE == 4 || BIT_SIZE == 5
            let x_u8 =  load_data(data,block_qs_byte + j,0xFF);
            #if BIT_SIZE == 5
                let xh_0 = (((qh >> j) << 4) & 0x10);
                let xh_1 = ((qh >> (j + 12)) & 0x10);

                let x0 = (x_u8 & 0x0F) | xh_0;
                let x1 = (x_u8 >> 4) | xh_1;
                #define DEFAULT_M_OFFSET 16
            #else
                let x0 = x_u8 & 0x0F;
                let x1 = x_u8 >> 4;
                #define DEFAULT_M_OFFSET 8
            #endif

            #ifdef M_OFFSET 
                CALLBACK(j           , f32(x0)*d+m)
                CALLBACK(j + FOR_SIZE, f32(x1)*d+m)
            #else
                CALLBACK(j           , f32(i32(x0) - DEFAULT_M_OFFSET)*d)
                CALLBACK(j + FOR_SIZE, f32(i32(x1) - DEFAULT_M_OFFSET)*d)
            #endif
        #elif BIT_SIZE == 8
            let x_u8 =  load_data(data,block_qs_byte + j,0xFF);
            let x_unsigned = i32(x_u8 << (32-BIT_SIZE)) >> (32-BIT_SIZE);
            #ifdef M_OFFSET 
                CALLBACK(j           , f32(x_unsigned)*d+m)
            #else
                CALLBACK(j           , f32(x_unsigned)*d)
            #endif
        #endif
    }

#endif